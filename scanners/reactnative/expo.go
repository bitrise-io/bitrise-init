package reactnative

import (
	"fmt"
	"path/filepath"

	"github.com/bitrise-io/bitrise-init/models"
	"github.com/bitrise-io/bitrise-init/steps"
	"github.com/bitrise-io/bitrise-init/utility"
	envmanModels "github.com/bitrise-io/envman/models"
	"github.com/bitrise-io/go-utils/log"
	"gopkg.in/yaml.v2"
)

const (
	expoConfigName        = "react-native-expo-config"
	expoDefaultConfigName = "default-" + expoConfigName
)

const (
	bareIOSProjectPathInputTitle   = "The iOS project path generated by running 'expo eject' locally"
	bareIOSprojectPathInputSummary = `Will add the Expo Eject Step to the Workflow to generate the native iOS project, so it can be built and archived.
Run 'expo eject' in a local environment to determine this value. This experiment then can be undone by deleting the ios and android directories. See https://docs.expo.io/bare/customizing/ for more details.
For example: './ios/myproject.xcworkspace'.`
)

const (
	iosBundleIDInputTitle   = "iOS bundle identifier"
	iosBundleIDInputSummary = `Key expo/ios/bundleIdentifier not present in 'app.json'.

Will add the Expo Eject Step to the Workflow to generate the native iOS project, so the IPA can be exported.
For your convenience, define it here temporarily. To set this value permanently run 'expo eject' in a local environment and commit 'app.json' changes.
For example: 'com.sample.myapp'.`
	iosBundleIDInputSummaryDefault = `Optional, only needs to be entered if the key expo/ios/bundleIdentifier is not set in 'app.json'.

Will add the Expo Eject Step to the Workflow to generate the native iOS project, so the IPA can be exported.
For your convenience, define it here temporarily. To set this value permanently run 'expo eject' in a local environment and commit 'app.json' changes.
For example: 'com.sample.myapp'.`
	iosBundleIDEnvKey = "EXPO_BARE_IOS_BUNLDE_ID"
)

const (
	androidPackageInputTitle   = "Android package name"
	androidPackageInputSummary = `Key expo/android/package not present in 'app.json'.

Will add the Expo Eject Step to the Workflow to generate the native Android project, so the bundle (AAB) can be built.
For your convenience, define it here temporarily. To set this value permanently run 'expo eject' in a local environment and commit 'app.json' changes.
For example: 'com.sample.myapp'.`
	androidPackageInputSummaryDefault = `Optional, only needs to be entered if the key expo/android/package is not set in 'app.json'.

Will add the Expo Eject Step to the Workflow to generate the native Android project, so the bundle (AAB) can be built.
For your convenience, define it here temporarily. To set this value permanently run 'expo eject' in a local environment and commit 'app.json' changes.
For example: 'com.sample.myapp'.`
	androidPackageEnvKey = "EXPO_BARE_ANDROID_PACKAGE"
)

const (
	iosDevelopmentTeamInputTitle   = "iOS Development team ID"
	iosDevelopmentTeamInputSummary = `The Apple Development Team that the iOS version of the app belongs to. Will be used to override code signing settings. See https://devcenter.bitrise.io/getting-started/getting-started-with-expo-apps/#signing-and-exporting-your-ios-app-for-deployment for more details.

Will add the Expo Eject Step to the Workflow to generate the native iOS project, so it can be built and archived.
Run 'expo eject' in a local environment to determine this value. This experiment then can be undone by deleting the ios and android directories.
For example: '1MZX23ABCD4'.`
	iosDevelopmentTeamEnv = "BITRISE_IOS_DEVELOPMENT_TEAM"
)

const (
	projectRootDirInputTitle   = "Project root directory"
	projectRootDirInputSummary = "The directory of the 'app.json' or 'package.json' file of your React Native project."
)

const (
	schemeInputTitle   = "The iOS native project scheme name"
	schemeInputSummary = `An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute. You can change the scheme at any time.

Will add the Expo Eject Step to the Workflow to generate the native iOS project, so it can be built and archived.
Run 'expo eject' in a local environment to determine this value. This experiment then can be undone by deleting the ios and android directories.`
)

const wordirEnv = "WORKDIR"

const (
	expoBareAddIdentiferScriptTitle = "Set bundleIdentifier, packageName for Expo Eject"
	expoAppJSONName                 = "app.json"
)

func expoBareAddIdentifiersScript(appJSONPath, androidEnvKey, iosEnvKey string) string {
	return fmt.Sprintf(`#!/usr/bin/env bash
set -ex

appJson="%s"
tmp="/tmp/app.json"
jq '.expo.android |= if has("package") or env.`+androidEnvKey+` == "" or env.`+androidEnvKey+` == null then . else .package = env.`+androidEnvKey+` end |
.expo.ios |= if has("bundleIdentifier") or env.`+iosEnvKey+` == "" or env.`+iosEnvKey+` == null then . else .bundleIdentifier = env.`+iosEnvKey+` end' <${appJson} >${tmp}
[[ $?==0 ]] && mv -f ${tmp} ${appJson}`, appJSONPath)
}

// expoOptions implements ScannerInterface.Options function for Expo based React Native projects.
func (scanner *Scanner) expoOptions() (models.OptionNode, models.Warnings, error) {
	return models.OptionNode{}, models.Warnings{}, nil
}

// expoConfigs implements ScannerInterface.Configs function for Expo based React Native projects.
func (scanner *Scanner) expoConfigs(isPrivateRepo bool) (models.BitriseConfigMap, error) {
	configMap := models.BitriseConfigMap{}

	// determine workdir
	packageJSONDir := filepath.Dir(scanner.packageJSONPth)
	relPackageJSONDir, err := utility.RelPath(scanner.searchDir, packageJSONDir)
	if err != nil {
		return models.BitriseConfigMap{}, fmt.Errorf("Failed to get relative package.json dir path, error: %s", err)
	}
	if relPackageJSONDir == "." {
		// package.json placed in the search dir, no need to change-dir in the workflows
		relPackageJSONDir = ""
	}
	log.TPrintf("Working directory: %v", relPackageJSONDir)

	// primary workflow
	configBuilder := models.NewDefaultConfigBuilder()
	primaryDescription := primaryExpoWorkflowNoTestsDescription
	if scanner.hasTest {
		primaryDescription = primaryExpoWorkflowDescription
	}

	configBuilder.SetWorkflowDescriptionTo(models.PrimaryWorkflowID, primaryDescription)
	configBuilder.AppendStepListItemsTo(models.PrimaryWorkflowID, steps.DefaultPrepareStepListV2(steps.PrepareListParams{
		ShouldIncludeCache:       false,
		ShouldIncludeActivateSSH: isPrivateRepo,
	})...)
	configBuilder.AppendStepListItemsTo(models.PrimaryWorkflowID, scanner.getTestSteps(relPackageJSONDir)...)

	configBuilder.AppendStepListItemsTo(models.PrimaryWorkflowID, steps.DefaultDeployStepListV2(false)...)

	// deploy workflow
	// TODO: deploy wf description update
	configBuilder.SetWorkflowDescriptionTo(models.DeployWorkflowID, deployExpoWorkflowDescription)
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, steps.DefaultPrepareStepListV2(steps.PrepareListParams{
		ShouldIncludeCache:       false,
		ShouldIncludeActivateSSH: isPrivateRepo,
	})...)
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, scanner.getTestSteps(relPackageJSONDir)...)
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, steps.RunEASBuildStepListItem(envmanModels.EnvironmentItemModel{"work_dir": relPackageJSONDir}))
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, steps.DefaultDeployStepList(false)...)

	// generate bitrise.yml
	bitriseDataModel, err := configBuilder.Generate(scannerName)
	if err != nil {
		return models.BitriseConfigMap{}, err
	}

	data, err := yaml.Marshal(bitriseDataModel)
	if err != nil {
		return models.BitriseConfigMap{}, err
	}

	configMap[expoConfigName] = string(data)

	return configMap, nil
}

// expoDefaultOptions implements ScannerInterface.DefaultOptions function for Expo based React Native projects.
func (Scanner) expoDefaultOptions() models.OptionNode {
	// TODO: update options with Expo wording
	workDirOption := models.NewOption(projectRootDirInputTitle, projectRootDirInputSummary, wordirEnv, models.TypeUserInput)
	return *workDirOption
}

// expoDefaultConfigs implements ScannerInterface.DefaultConfigs function for Expo based React Native projects.
func (scanner Scanner) expoDefaultConfigs() (models.BitriseConfigMap, error) {
	// TODO: should we ask if test, if yarn, which platform to deploy?
	configMap := models.BitriseConfigMap{}

	// primary workflow
	configBuilder := models.NewDefaultConfigBuilder()
	configBuilder.SetWorkflowDescriptionTo(models.PrimaryWorkflowID, primaryExpoWorkflowDescription)
	configBuilder.AppendStepListItemsTo(models.PrimaryWorkflowID, steps.DefaultPrepareStepListV2(steps.PrepareListParams{
		ShouldIncludeCache:       false,
		ShouldIncludeActivateSSH: true,
	})...)
	configBuilder.AppendStepListItemsTo(models.PrimaryWorkflowID, getTestSteps("$WORKDIR", true, true)...)
	configBuilder.AppendStepListItemsTo(models.PrimaryWorkflowID, steps.DefaultDeployStepListV2(false)...)

	// deploy workflow
	configBuilder.SetWorkflowDescriptionTo(models.DeployWorkflowID, deployExpoWorkflowDescription)
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, steps.DefaultPrepareStepListV2(steps.PrepareListParams{
		ShouldIncludeCache:       false,
		ShouldIncludeActivateSSH: true,
	})...)
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, getTestSteps("$WORKDIR", true, true)...)
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, steps.RunEASBuildStepListItem(envmanModels.EnvironmentItemModel{"work_dir": "$WORKDIR"}))
	configBuilder.AppendStepListItemsTo(models.DeployWorkflowID, steps.DefaultDeployStepList(false)...)

	// generate bitrise.yml
	bitriseDataModel, err := configBuilder.Generate(scannerName)
	if err != nil {
		return models.BitriseConfigMap{}, err
	}

	data, err := yaml.Marshal(bitriseDataModel)
	if err != nil {
		return models.BitriseConfigMap{}, err
	}

	configMap[expoDefaultConfigName] = string(data)

	return configMap, nil
}
